<section>
	<h2>Lumber Segmenter</h2>
	<div class="row">
		<table>
			<tr>
				<td>Technologies</td>
				<td>JavaScript, jQuery</td>
			</tr>
			<tr>
				<td>Run</td>
				<td><a href="/tools/lumber/" rel="external">brendan-w.com/tools/lumber/</a></td>
			</tr>
			<tr>
				<td>Source Code</td>
				<td><a href="https://github.com/brendan-w/lumber-segmenter">https://github.com/brendan-w/lumber-segmenter</a></td>
			</tr>
			<tr>
				<td>License</td>
				<td>MIT</td>
			</tr>
		</table>
	</div>
	<div class="row">
		<div class='col'>
			<p>
				This is a woodworking tool that generates cut patterns with minimum waste. After accepting length and quantity data from the user, a cut pattern is generated and displayed. There are also options for setting the kerf (width) of the saw being used, as well as a selection of layout algorithms. The finished layouts are color-coded for clarity, and are readily printable.
			</p>
		</div>
		<div class='col'>
			<p>
				This tool will also handle unlimited quantities of wood. If you are making a shopping list for a project, this tool is useful for computing the minimum number of boards needed.
			</p>
		</div>
	</div>
</section>
<section>
	<h3>Interface</h3>
	<div class="row">
		<img src="/assets/projects/lumber.png">
	</div>
</section>
<section>
	<h3>Algorithms</h3>
	<div class="row">
		<div class='col'>
			<p>
				The largest challenge, by far, was crafting the algorithms that solve for the layout. There are currently two solvers available. One solver recursively searches for the layout with the least loss, while the other uses a less brute force technique to find a sub-optimal layout. The recursive solver is guaranteed to return an optimal layout, however, it is not always practical due to its slow speeds with large inputs. When this happens, the sub-optimal solver may be preferable.
			</p>
			<p>
				Internally, the optimal solver uses double recursion to permute through the various combinations of cut sizes and source material sizes. To accelerate the process, the recursive functions do not operate on individual board objects, but loop through the size choices provided by the user. This prevents the computer from trying the same board size more than once at any given step in the process.
			</p>
		</div>
		<div class="col">
			<p>
				The sub-optimal solver is essentially a narrower version of the full solver, because it only performing single recursion. Rather than testing for minimum loss on whole, completed layouts, this solver only operates on one board at a time. It loops through each available board size, and uses recursion to find the best arrangement of cuts on that board. The computer then selects the board size (and cut pattern) that generated the least loss, and then moves on. This process is repeated until there are no more cuts left to make. A useful property of this solver is that it will always return optimal layouts when all source materials are marked as unlimited.
			</p>
			<p>
				To handle unlimited quantities, the computer will simply add as many source boards as there are cuts. This ensures that there is at least one source board for every cut. If a cut size is larger than any of the users sources, the solver will fail, and an error message will be displayed.
			</p>
		</div>
	</div>
	<div class="row">
		<div class='col'>
			<img src="/assets/projects/lumber_before.png">
		</div>
		<div class='col'>
			<img src="/assets/projects/lumber_after.jpg">
		</div>
	</div>
</section>
